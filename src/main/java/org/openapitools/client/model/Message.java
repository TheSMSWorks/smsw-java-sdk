/*
 * The SMS Works API
 * The SMS Works provides a low-cost, reliable SMS API for developers. Pay only for delivered texts, all failed UK messages are refunded.
 *
 * The version of the OpenAPI document: 1.9.0
 * Contact: support@thesmsworks.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MessageMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SMS message object
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-15T11:27:24.989260Z[Europe/London]")
public class Message {
  public static final String SERIALIZED_NAME_SENDER = "sender";
  @SerializedName(SERIALIZED_NAME_SENDER)
  private String sender;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private String destination;

  public static final String SERIALIZED_NAME_CONTENT = "content";
  @SerializedName(SERIALIZED_NAME_CONTENT)
  private String content;

  public static final String SERIALIZED_NAME_DELIVERYREPORTURL = "deliveryreporturl";
  @SerializedName(SERIALIZED_NAME_DELIVERYREPORTURL)
  private String deliveryreporturl;

  public static final String SERIALIZED_NAME_SCHEDULE = "schedule";
  @SerializedName(SERIALIZED_NAME_SCHEDULE)
  private String schedule;

  public static final String SERIALIZED_NAME_TAG = "tag";
  @SerializedName(SERIALIZED_NAME_TAG)
  private String tag;

  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  private BigDecimal ttl;

  public static final String SERIALIZED_NAME_RESPONSEEMAIL = "responseemail";
  @SerializedName(SERIALIZED_NAME_RESPONSEEMAIL)
  private List<String> responseemail;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private MessageMetadata metadata;

  public static final String SERIALIZED_NAME_VALIDITY = "validity";
  @SerializedName(SERIALIZED_NAME_VALIDITY)
  private BigDecimal validity;

  public static final String SERIALIZED_NAME_AI = "ai";
  @SerializedName(SERIALIZED_NAME_AI)
  private Boolean ai;

  public Message() {
  }

  public Message sender(String sender) {
    
    this.sender = sender;
    return this;
  }

   /**
   * The sender of the message. Should be no longer than 11 characters for alphanumeric or 15 characters for numeric sender ID&#39;s. No spaces or special characters.
   * @return sender
  **/
  @javax.annotation.Nonnull
  public String getSender() {
    return sender;
  }


  public void setSender(String sender) {
    this.sender = sender;
  }


  public Message destination(String destination) {
    
    this.destination = destination;
    return this;
  }

   /**
   * Telephone number of the recipient
   * @return destination
  **/
  @javax.annotation.Nonnull
  public String getDestination() {
    return destination;
  }


  public void setDestination(String destination) {
    this.destination = destination;
  }


  public Message content(String content) {
    
    this.content = content;
    return this;
  }

   /**
   * Message to send to the recipient. Content can be up to 1280 characters in length. Messages of 160 characters or fewer are charged 1 credit. If your message is longer than 160 characters then it will be broken down in to chunks of 153 characters before being sent to the recipient&#39;s handset, and you will be charged 1 credit for each 153 characters. Messages sent to numbers registered outside the UK will be typically charged double credits, but for certain countries may be charged fractions of credits (e.g. 2.5). Please contact us for rates for each country.
   * @return content
  **/
  @javax.annotation.Nonnull
  public String getContent() {
    return content;
  }


  public void setContent(String content) {
    this.content = content;
  }


  public Message deliveryreporturl(String deliveryreporturl) {
    
    this.deliveryreporturl = deliveryreporturl;
    return this;
  }

   /**
   * The url to which we should POST delivery reports to for this message. If none is specified, we&#39;ll use the global delivery report URL that you&#39;ve configured on your account page.
   * @return deliveryreporturl
  **/
  @javax.annotation.Nullable
  public String getDeliveryreporturl() {
    return deliveryreporturl;
  }


  public void setDeliveryreporturl(String deliveryreporturl) {
    this.deliveryreporturl = deliveryreporturl;
  }


  public Message schedule(String schedule) {
    
    this.schedule = schedule;
    return this;
  }

   /**
   * Date at which to send the message. This is only used by the message/schedule service and can be left empty for other services.
   * @return schedule
  **/
  @javax.annotation.Nullable
  public String getSchedule() {
    return schedule;
  }


  public void setSchedule(String schedule) {
    this.schedule = schedule;
  }


  public Message tag(String tag) {
    
    this.tag = tag;
    return this;
  }

   /**
   * An identifying label for the message, which you can use to filter and report on messages you&#39;ve sent later. Ideal for campaigns. A maximum of 280 characters.
   * @return tag
  **/
  @javax.annotation.Nullable
  public String getTag() {
    return tag;
  }


  public void setTag(String tag) {
    this.tag = tag;
  }


  public Message ttl(BigDecimal ttl) {
    
    this.ttl = ttl;
    return this;
  }

   /**
   * The optional number of minutes before the delivery report is deleted. Optional. Omit to prevent delivery report deletion. Integer.
   * @return ttl
  **/
  @javax.annotation.Nullable
  public BigDecimal getTtl() {
    return ttl;
  }


  public void setTtl(BigDecimal ttl) {
    this.ttl = ttl;
  }


  public Message responseemail(List<String> responseemail) {
    
    this.responseemail = responseemail;
    return this;
  }

  public Message addResponseemailItem(String responseemailItem) {
    if (this.responseemail == null) {
      this.responseemail = new ArrayList<>();
    }
    this.responseemail.add(responseemailItem);
    return this;
  }

   /**
   * An optional list of email addresses to forward responses to this specific message to. An SMS Works Reply Number is required to use this feature.
   * @return responseemail
  **/
  @javax.annotation.Nullable
  public List<String> getResponseemail() {
    return responseemail;
  }


  public void setResponseemail(List<String> responseemail) {
    this.responseemail = responseemail;
  }


  public Message metadata(MessageMetadata metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @javax.annotation.Nullable
  public MessageMetadata getMetadata() {
    return metadata;
  }


  public void setMetadata(MessageMetadata metadata) {
    this.metadata = metadata;
  }


  public Message validity(BigDecimal validity) {
    
    this.validity = validity;
    return this;
  }

   /**
   * The optional number of minutes to attempt delivery before the message is marked as EXPIRED. Optional. The default is 2880 minutes. Integer.
   * minimum: 1
   * maximum: 2880
   * @return validity
  **/
  @javax.annotation.Nullable
  public BigDecimal getValidity() {
    return validity;
  }


  public void setValidity(BigDecimal validity) {
    this.validity = validity;
  }


  public Message ai(Boolean ai) {
    
    this.ai = ai;
    return this;
  }

   /**
   * Used to determine whether The SMS Works AI Optimiser should be used in the event that the message is just longer than the 1 or 2 credit boundary. This setting overrides the AI Optimiser configuration on your SMS Works account.
   * @return ai
  **/
  @javax.annotation.Nullable
  public Boolean getAi() {
    return ai;
  }


  public void setAi(Boolean ai) {
    this.ai = ai;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Message message = (Message) o;
    return Objects.equals(this.sender, message.sender) &&
        Objects.equals(this.destination, message.destination) &&
        Objects.equals(this.content, message.content) &&
        Objects.equals(this.deliveryreporturl, message.deliveryreporturl) &&
        Objects.equals(this.schedule, message.schedule) &&
        Objects.equals(this.tag, message.tag) &&
        Objects.equals(this.ttl, message.ttl) &&
        Objects.equals(this.responseemail, message.responseemail) &&
        Objects.equals(this.metadata, message.metadata) &&
        Objects.equals(this.validity, message.validity) &&
        Objects.equals(this.ai, message.ai);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sender, destination, content, deliveryreporturl, schedule, tag, ttl, responseemail, metadata, validity, ai);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Message {\n");
    sb.append("    sender: ").append(toIndentedString(sender)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    content: ").append(toIndentedString(content)).append("\n");
    sb.append("    deliveryreporturl: ").append(toIndentedString(deliveryreporturl)).append("\n");
    sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    responseemail: ").append(toIndentedString(responseemail)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    validity: ").append(toIndentedString(validity)).append("\n");
    sb.append("    ai: ").append(toIndentedString(ai)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("sender");
    openapiFields.add("destination");
    openapiFields.add("content");
    openapiFields.add("deliveryreporturl");
    openapiFields.add("schedule");
    openapiFields.add("tag");
    openapiFields.add("ttl");
    openapiFields.add("responseemail");
    openapiFields.add("metadata");
    openapiFields.add("validity");
    openapiFields.add("ai");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("sender");
    openapiRequiredFields.add("destination");
    openapiRequiredFields.add("content");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Message
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Message.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Message is not found in the empty JSON string", Message.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Message.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Message` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Message.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("sender").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sender` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sender").toString()));
      }
      if (!jsonObj.get("destination").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destination` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination").toString()));
      }
      if (!jsonObj.get("content").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `content` to be a primitive type in the JSON string but got `%s`", jsonObj.get("content").toString()));
      }
      if ((jsonObj.get("deliveryreporturl") != null && !jsonObj.get("deliveryreporturl").isJsonNull()) && !jsonObj.get("deliveryreporturl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deliveryreporturl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deliveryreporturl").toString()));
      }
      if ((jsonObj.get("schedule") != null && !jsonObj.get("schedule").isJsonNull()) && !jsonObj.get("schedule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schedule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schedule").toString()));
      }
      if ((jsonObj.get("tag") != null && !jsonObj.get("tag").isJsonNull()) && !jsonObj.get("tag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tag").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("responseemail") != null && !jsonObj.get("responseemail").isJsonNull() && !jsonObj.get("responseemail").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `responseemail` to be an array in the JSON string but got `%s`", jsonObj.get("responseemail").toString()));
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        MessageMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Message.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Message' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Message> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Message.class));

       return (TypeAdapter<T>) new TypeAdapter<Message>() {
           @Override
           public void write(JsonWriter out, Message value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Message read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Message given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Message
  * @throws IOException if the JSON string is invalid with respect to Message
  */
  public static Message fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Message.class);
  }

 /**
  * Convert an instance of Message to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

